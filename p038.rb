#!/usr/bin/ruby
require 'pe_mylib'
desc "(1,2,..n)n>2との連結積によって生成される9桁のpandigital数のうち一番大きなものは？"

# 定義
#   連結積 : 192と(1,2,3)の連結積 -> [192*1,192*2,192*3].join -> [192,384,576].join -> 192384576
#   pandigital数 : n進数で0からn-1までのすべての数が少なくとも1つ以上使われている数
#                  この問題の場合、1〜9までの数のことを指しているのかな？

# 考え中メモ
#   pandigital数だけで考えると,9桁のpandigital数で最大の数は987654321。
#
#   n=1の場合、987654321(1) -> 987654321*1 -> 987654321が一番大きな数だが
#   n>1の条件がついているのでこれはダメ
#
#   問題の例として9(5)->[9*1,9*2,...9*5].join->918273645の例が示されているが
#   これは答えではない。(フォームに入力して確認したw)
#
#   ということは、答えは918273646〜987654321の間にある数のはず。
#   (約7000万個の数が該当する...)
#
#   重要：答えは9から始まるpandigital数に限定できる。
#
#   問題の攻略方法として以下の要素を考える必要がある
#     * 順に列挙する方法
#       * 効率よく探索できる列挙方法
#     * 探索範囲の絞り込み
#
#   関数concatenated_product(i, max_n)の結果が9桁になるケースについて考えてみる
#     a*bの計算結果の桁数は(aの桁数+bの桁数-1)〜(aの桁数+bの桁数)の範囲に収まるのを
#     考慮して順にiが1桁のケースから順に考える
#
#   iが1桁の場合、max_nは5〜9のはず。
#       最小:1(9)
#       最大:9(5)
#       ただし、9(5)は問題から最大数ではないことが分かっているので
#       iが1桁の場合は考えない。
#  
#   iが2桁の場合、max_nは4のはず
#       i=11の場合: 11+22+33+44... -> 2桁+2桁+2桁+2桁...となり9桁にならない
#       i=99の場合: 99+198+297+... -> 2桁+3桁+3桁+3桁...となり9桁にならない
#
#       ありえるケースとしては、max_nが4で2桁+2桁+2桁+3桁となるケース
#
#       重要：1番目の項は必ず1と同じ桁数になる
#
#   1が3桁の場合、max_nは3のはず？
#     3桁+3桁+3桁のケースしか考えられない？
# 
#   1が4桁の場合、max_nは2のはず？
#     4桁+5桁のケースしか考えられない
#
#   1が5〜8桁の場合
#     これはちょうど9桁になるケースがない
#
#   iが9桁の場合、max_nは1
#
#

#連結積を求める
def concatenated_product(i, max_n)
  num_str = ""
  (1..max_n).each {|n|
    num_str += (i * n).to_s
  }
  return num_str.to_i
end

# 9桁のpandigital数かどうかをチェックする
def pandigital?(n)
  return false unless n.digit == 9

  m = {}
  n.each_digit{|d|
    m[d] = true
  }
  (1..9).each {|d|
    return false unless m.key?(d)
  }
  true
end

# how to use...
#pp concatenated_product(192, 3)  # 192384576
#pp pandigital?(1)                # false
#pp pandigital?(123456789)        # true
#pp pandigital?(123456788)        # false


# 結果の出力
rv = "not implemented..."
puts "result = #{rv}"
