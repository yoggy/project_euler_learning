#!/usr/bin/ruby
require 'pe_mylib'
desc "5つの素数の組み合わせの中から任意の2つの素数を取り出し、任意の順番で連結しても素数になる素数の組で合計が最小のものは？"

#
# 問題では例として次の4組の素数が紹介されている
#
# 3, 7, 109, 673
#
#    3,   7 -> 37, 73
#    3, 109 -> 3109, 1093
#    3, 673 -> 3673, 6733
#    7, 109 -> 7109, 1097
#    7, 673 -> 7673, 6737
#  109, 673 -> 109673, 673109
#
# 合計が小さい数順で探索するように方法を工夫しないとだめかも。。
# Array.choice_and_callのアルゴリズムだと最後の桁が配列の最後の要素まで探索してしまうのでダメ。。
#
# 例:2つ選ぶ場合
#   1,2,3,4,5,6,7
#   1,2
#   1,3
#   2,3
#   1,4
#   2,4
#   3,4
#
# 例:3つ選ぶ場合
#   1,2,3,4,5,...
#   1,2,3
#   1,2,4
#   2,3,4
#   1,2,5
#   1,3,5
#   1,4,5
#   2,3,5
#   2,4,5
#   3,4,5
#
# ...というか普通に考えたら673(素数の122番目)までを総当たりして5つ選んでいたら
#
#   c(122,5) = 207288004
#
# なので、ちょっと総当たり回数が多すぎるような気がする。
# 別の方法を考えた方がよさげ...
#
# 例えば、3, 7, 109, 673に何か1つ数字を加えた物が答えの組じゃないか？と想像
#
#   2つの場合 -> 3, 7
#   3つの場合 -> 3, 7, 109
#   4つの場合 -> 3, 7, 109, 673
#   5つの場合 -> 3, 7, 109, 673, ?
#       :
#       :
# という感じで構成されているんじゃないか？ということで、まずは3つの場合を検証してみる
#

require 'prime_table'

# 前と後ろに連結して、どちらも素数であるかどうかを判定する
def join_prime?(n, p)
  return false unless (n.to_s + p.to_s).to_i.prime?
  return false unless (p.to_s + n.to_s).to_i.prime?
  true
end

# 結果の出力
a = [3, 7, 109, 673]
prime = Prime.new
loop {
  p = prime.succ  
  next if a.max >= p 

  # あらかじめ求めてある結果と新たな素数との間で
  # 任意の連結で素数になるかどうかチェック
  r = a.map{|n| join_prime?(n, p)}.inject(true) {|r,n| r && n}
  if r 
    puts "hit!!! p=#{p}"
    a << p
    break
  end
}
pp a
puts "result = #{a.sum}"

